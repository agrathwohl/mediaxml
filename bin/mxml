#!/usr/bin/env node

const { Parser, ParserNode, ParserNodeFragment, ParserNodeAttributes } = require('../parser')
const { inspect } = require('util')
const chromafi = require('@12core/chromafi')
const mkdirp = require('mkdirp')
const debug = require('debug')('mediaxml')
const paths = require('env-paths')('mediaxml')
const path = require('path')
const repl = require('repl')
const pkg = require('../package.json')
const fs = require('fs')

const argv = require('minimist')(process.argv.slice(2), {
  alias: {
    h: ['help'],
    i: ['inspect'],
    D: ['debug'],
    V: ['version'],
  },

  boolean: [
    'version',
    'inspect',
    'debug',
    'help'
  ]
})

if (argv.help) {
  console.log('usage: mxml [-hiDV] [options] <filename> [query]')
  console.log('')
  console.log('options:')
  console.log('  -h, --help      Show this message')
  console.log('  -i, --inspect   Show inspected output')
  console.log('  -D, --debug     Show debug output')
  console.log('  -V, --version   Show program version')
  console.log('')
  console.log('arguments:')
  console.log('  <filename>      Path to XML file (required)')
  console.log('  [query]         Query in JSONata syntax on resulting model [optional]')
  console.log('')
  console.log('examples:')
  console.log('  ## read ADI metadata')
  console.log('  mxml ./tvshow.xml \'adi:children [name="metadata"]\'')
  console.log('')
  console.log('  ## look for ADI3 "Movie" assets')
  console.log('  mxml ./movie.xml \'adi3:children [`xsi:type`="content:MovieType"]\'')
  console.log('')
  process.exit(0)
}

if (argv.version) {
  console.log(pkg.version)
  process.exit(0)
}

if (argv.debug) {
  require('debug').enable('mediaxml')
  debug('Debug output enabled')
}

if (!argv._[0]) {
  console.error('error: Please specify a filename')
  console.error('usage: mxml [-hiDV] [options] <filename> [query]')
  process.exit(1)
}

const filename = path.resolve(process.cwd(), argv._[0])
const stream = fs.createReadStream(filename)
const parser = new Parser()

stream.pipe(parser.createWriteStream())
  .on('error', (err) => {
    console.error('error: %s', err.message)
    debug(err.stack || err)
  })
  .on('finish', () => {
    const [, query ] = argv._

    if (query) {
      const result = parser.query(query, {
        inspect: Boolean(argv.inspect)
      })

      if (result && argv.inspect) {
        let output = inspect.custom in result ? result[inspect.custom]() : result

        if (Array.isArray(output)) {
          output = output.reduce((s, o) => s + (
            (o && 'object' === typeof o && inspect.custom in o ) ? o[inspect.custom]() : o
          ) + '\n', '')
        }

        output = chromafi(output.trim(), {
          consoleTabWidth: 2,
          lineNumberPad: 0,
          tabsToSpaces: 8,
          lineNumbers: false,
          stripIndent: false,
          decorate: false,
          codePad: 0,
          lang: 'xml'
        })

        console.log('\n%s', output.trim())
      } else {
        console.log(result)
      }
    } else {
      const replServerHistoryPath = path.join(paths.data, 'repl.history')
      const server = repl.start({
        completer,
        preview: true,
        prompt: `mxml (${path.basename(filename)})> `,
        eval: evaluate
      })

      server.on('error', (err) => {
        console.error('error:', err.message)
        debug(err.stack || err)
      })

      try {
        mkdirp.sync(path.dirname(replServerHistoryPath))
      } catch (err) {
        console.error('error:', err.message)
        debug(err.stack || err)
        process.exit(1)
        return
      }

      server.setupHistory(replServerHistoryPath, (err) => {
        if (err) {
          debug(err.stack || err)
        }
      })
    }
  })

function pretty(result) {
  if (
    !ParserNode.isParserNode(result) &&
    false === (result instanceof ParserNodeAttributes)
  ) {
    return inspect(result, { colors: true })
  }

  let output = inspect.custom in result ? result[inspect.custom]() : result

  if (Array.isArray(output)) {
    return output.reduce((s, o) => s + (
      print((o && 'object' === typeof o && inspect.custom in o ) ? o[inspect.custom]() : o)
    ) + '\n', '')
  }

  return print(output)

  function print(out) {
    return chromafi(out, {
      consoleTabWidth: 2,
      lineNumberPad: 0,
      tabsToSpaces: 8,
      lineNumbers: false,
      stripIndent: false,
      decorate: false,
      codePad: 0,
      lang: 'xml'
    })
  }
}

function evaluate(query, context, file, callback) {
  query = query.trim()

  if (!query) {
    return callback(null)
  }

  try {
    const result = parser.rootNode.query(query)
    if (result  && 'object' === typeof result) {
      const output = pretty(result)
      if (output) {
        process.stdout.write(output)
        process.stdout.write('\n')
      }
    } else {
      console.log(result)
    }
    callback(null)
  } catch (err) {
    debug(err.stack || err)
    callback(err.message)
  }
}

function completer(query) {
  const parts = query.split(':')
  const end = parts.pop()

  const completions = [
    ':is',
    ':json',
    ':keys',
    ':text',

    ':attr',
    ':attrs',

    ':children',
    ':nth-child',
  ]

  if (/\:children\:/.test(query)) {
    completions.push(
      ':first',
      ':second',
      ':third',
      ':fourth',
      ':fifth',
      ':sixth',
      ':seventh',
      ':eighth',
      ':ninth',
      ':tenth'
    )
  }

  if (!query || ':' === query || /\:?r?o?o?t?/.test(query)) {
    completions.unshift(':root')
  }

  if (/\[\s+$/.test(query)) {
    completions.push(...[
      'attributes',
      'children',
      'attr(',
      'name',
      'text'
    ])
  }

  const hits = completions
    .filter((c) => c.startsWith(`:${end}`))
    .map((c) => parts.join(':') + c)

  return  [hits.length ? hits.sort() : completions.sort(), query]
}
