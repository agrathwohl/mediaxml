#!/usr/bin/env node

const { pretty } = require('../repl/pretty')
const debug = require('debug')('mediaxml')
const path = require('path')
const repl = require('../repl')
const pkg = require('../package.json')

const argv = require('minimist')(process.argv.slice(2), {
  '--': true,
  alias: {
    h: ['help'],
    i: ['inspect'],
    D: ['debug'],
    j: ['json'],
    P: ['pretty'],
    R: ['repl'],
    T: ['timing'],
    V: ['version'],
    W: ['watch'],
  },

  default: {
    pretty: true
  },

  boolean: [
    'debug',
    'inspect',
    'help',
    'json',
    'no-preview',
    'pretty',
    'preview',
    'repl',
    'timing',
    'version',
    'watch',
  ]
})

if (argv.help) {
  process.stdout.write('usage: mxml [-hiDRTV] [options] <filename> [query]\n')
  process.stdout.write('\n')
  process.stdout.write('options:\n')
  process.stdout.write('  -h, --help      Show this message\n')
  process.stdout.write('  -i, --inspect   Show inspected output\n')
  process.stdout.write('  -D, --debug     Show debug output\n')
  process.stdout.write('  -j, --json      Convert output to JSON\n')
  process.stdout.write('  -P, --pretty    Show pretty output (default in most cases)\n')
  process.stdout.write('  -R, --repl      Launch program REPL\n')
  process.stdout.write('  -T, --timing    Show query timing debug output\n')
  process.stdout.write('  -V, --version   Show program version\n')
  process.stdout.write('  -W, --watch     Watch for changes (REPL context only)\n')
  process.stdout.write('\n')
  process.stdout.write('arguments:\n')
  process.stdout.write('  <filename>      Path to XML file (required)\n')
  process.stdout.write('  [query]         Query in JSONata syntax on resulting model [optional]\n')
  process.stdout.write('\n')
  process.stdout.write('examples:\n')
  process.stdout.write('  ## read ADI metadata\n')
  process.stdout.write('  mxml ./tvshow.xml \'adi:children [name="metadata"]\'\n')
  process.stdout.write('\n')
  process.stdout.write('  ## look for ADI3 "Movie" assets\n')
  process.stdout.write('  mxml ./movie.xml \'adi3:children [`xsi:type`="content:MovieType"]\'\n')
  process.stdout.write('\n')
  process.exit(0)
}

if (argv.version) {
  process.stdout.write(pkg.version)
  process.stdout.write('\n')
  process.exit(0)
}

if (argv.debug) {
  require('debug').enable('mediaxml')
  debug('Debug output enabled')
}

if (0 && !argv._[0] && process.stdin.isTTY) {
  console.error('error: Please specify a file path or URL')
  console.error('usage: mxml [-hiDV] [options] <uri> [query]')
  process.exit(1)
}

let [ arg0, query = arg0 ] = argv._

process.on('uncaughtException', debug)
process.on('unhandledRejection', debug)

if (arg0 && query && arg0 === query) {
  query = null
}

// try to load query as file
if (query) {
  try {
    fs.accessSync(query)
    query = fs.readFileSync(query, 'utf8')
  } catch (err) {
    void err
  }
}

if ('-' === argv._[0] || !process.stdin.isTTY) {
  if (!query) {
    console.error('error: stdin is not a TTY and no query was given')
    console.error('usage: mxml [-hiDV] [options] <uri> [query]')
    process.exit(1)
  }
} else if (arg0) {
  const context = repl.createContext(arg0, {
    onerror: console.error,
    preview: !('no-preview' in argv) && false !== argv.preview,
    timing: argv.timing,
    debug: argv.debug,
    argv: [argv._[0], ...argv['--']]
  })

  context.parser.then(async () => {
    const { imports } = context
    let result = await context.parser.query(`import "${arg0}"`, context)
    let output = null

    if (!result && imports.size) {
      const values = await Promise.all([ ...imports.values() ])
      while (values.length) {
        const value = values.pop()
        if (value) {
          result = value
          break
        }
      }
    }

    if (query) {
      result = await context.parser.query(query, context)
    }

    if (result) {
      if (argv.json) {
        if (argv.pretty) {
          process.stdout.write(JSON.stringify(result, null, '  '))
          process.stdout.write('\n')
        } else {
          process.stdout.write(JSON.stringify(result))
        }
        return
      } else {
        if (false !== argv.pretty) {
          output = pretty(result)
          if (output) {
            process.stdout.write(output)
            process.stdout.write('\n')
          }
        } else {
          console.log(result)
        }
      }
    }

    if (argv.repl) {
      context.start()
    }
  }).catch((err) => {
    context.log.error(err)
  })
} else {
  repl.start({
    onerror: console.error,
    preview: !('no-preview' in argv) && false !== argv.preview,
    timing: argv.timing,
    debug: argv.debug,
  })
}
