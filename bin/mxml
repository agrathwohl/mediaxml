#!/usr/bin/env node

const { Parser, ParserNode, ParserNodeFragment, ParserNodeAttributes } = require('../parser')
const { inspect } = require('util')
const chromafi = require('@12core/chromafi')
const { URL } = require('url')
const mkdirp = require('mkdirp')
const debug = require('debug')('mediaxml')
const chalk = require('chalk')
const paths = require('env-paths')('mediaxml')
const path = require('path')
const repl = require('repl')
const get = require('get-uri')
const pkg = require('../package.json')
const fs = require('fs')

const argv = require('minimist')(process.argv.slice(2), {
  alias: {
    h: ['help'],
    i: ['inspect'],
    D: ['debug'],
    V: ['version'],
  },

  boolean: [
    'version',
    'inspect',
    'debug',
    'help'
  ]
})

if (argv.help) {
  console.log('usage: mxml [-hiDV] [options] <filename> [query]')
  console.log('')
  console.log('options:')
  console.log('  -h, --help      Show this message')
  console.log('  -i, --inspect   Show inspected output')
  console.log('  -D, --debug     Show debug output')
  console.log('  -V, --version   Show program version')
  console.log('')
  console.log('arguments:')
  console.log('  <filename>      Path to XML file (required)')
  console.log('  [query]         Query in JSONata syntax on resulting model [optional]')
  console.log('')
  console.log('examples:')
  console.log('  ## read ADI metadata')
  console.log('  mxml ./tvshow.xml \'adi:children [name="metadata"]\'')
  console.log('')
  console.log('  ## look for ADI3 "Movie" assets')
  console.log('  mxml ./movie.xml \'adi3:children [`xsi:type`="content:MovieType"]\'')
  console.log('')
  process.exit(0)
}

if (argv.version) {
  console.log(pkg.version)
  process.exit(0)
}

if (argv.debug) {
  require('debug').enable('mediaxml')
  debug('Debug output enabled')
}

if (!argv._[0] && process.stdin.isTTY) {
  console.error('error: Please specify a file path or URL')
  console.error('usage: mxml [-hiDV] [options] <uri> [query]')
  process.exit(1)
}

const parser = new Parser()
let [ arg0, query = arg0 ] = argv._
let filename = null

if (arg0 && query && arg0 === query) {
  query = null
}

// try to load query as file
if (query) {
  try {
    fs.accessSync(query)
    query = fs.readFileSync(query, 'utf8')
  } catch (err) {
    void err
  }
}

if ('-' === argv._[0] || !process.stdin.isTTY) {

  if (!query) {
    console.error('error: stdin is not a TTY and no query was given')
    console.error('usage: mxml [-hiDV] [options] <uri> [query]')
    process.exit(1)
  }

  onstream(null, process.stdin)
} else {
  try {
    const { protocol } = new URL(argv._[0])
    filename = argv._[0]
  } catch (err) {
    if (err && 'ERR_INVALID_URL' !== err.code) {
      debug(err)
    } else {
      try {
        filename = path.resolve(process.cwd(), argv._[0])
        fs.accessSync(filename, fs.constants.R_OK | fs.constants.F_OK)
        filename = `file://${filename}`
      } catch (err) {
        void err
      }
    }
  }

  get(filename, onstream)
}

function onstream(err, stream) {
  if (err) {
    console.error('error: %s', err.message)
    debug(err.stack || err)
    process.exit(1)
    return
  }

  stream.pipe(parser.createWriteStream())
    .on('error', (err) => {
      console.error('error: %s', err.message)
      debug(err.stack || err)
    })
    .on('finish', () => {

      if (query) {
        const result = parser.query(query, {
          inspect: Boolean(argv.inspect)
        })

        if (result && argv.inspect) {
          output = pretty(result)

          if (output) {
            console.log('\n%s', output.trim())
          }
        } else {
          console.log(result)
        }
      } else if (process.stdin.isTTY) {
        const replServerHistoryPath = path.join(paths.data, 'repl.history')
        const server = repl.start({
          completer,
          terminal: true,
          preview: true,
          prompt: `${chalk.bold('mxml')} (${filename ? path.basename(filename.split('?')[0]) : '-'})> `,
          eval: evaluate
        })

        server.on('error', (err) => {
          console.error('error:', err.message)
          debug(err.stack || err)
        })

        try {
          mkdirp.sync(path.dirname(replServerHistoryPath))
        } catch (err) {
          console.error('error:', err.message)
          debug(err.stack || err)
          process.exit(1)
          return
        }

        server.setupHistory(replServerHistoryPath, (err) => {
          if (err) {
            debug(err.stack || err)
          }
        })
      }
    })
}

function pretty(result) {
  if (
    !ParserNode.isParserNode(result) &&
    false === (result instanceof ParserNodeAttributes)
  ) {
    return inspect(result, { colors: true })
  }

  let output = inspect.custom in result ? result[inspect.custom]() : result

  if (Array.isArray(output)) {
    return output.reduce((s, o) => s + (
      print((o && 'object' === typeof o && inspect.custom in o ) ? o[inspect.custom]() : o)
    ) + '\n', '')
  }

  return print(output)

  function print(out) {
    if (false === (out instanceof String) && 'object' !== typeof out && 'string' !== typeof out) {
      return out
    }

    return chromafi(out, {
      consoleTabWidth: 0,
      lineNumberPad: 0,
      tabsToSpaces: 2,
      lineNumbers: false,
      stripIndent: false,
      decorate: false,
      codePad: 0,
      lang: 'xml'
    })
  }
}

function evaluate(query, context, file, callback) {
  query = query.trim()

  console.time(chalk.bold('query'))
  if (!query) {
    return callback(null)
  }

  try {
    const result = parser.rootNode.query(query)
    if (result  && 'object' === typeof result) {
      const output = pretty(result)
      if (output) {
        process.stdout.write(output)
        process.stdout.write('\n')
      }
    } else {
      console.log(result)
    }
    console.timeEnd(chalk.bold('query'))
    callback(null)
  } catch (err) {
    debug(err.stack || err)
    console.timeEnd(chalk.bold('query'))
    callback(err.message)
  }
}

function completer(query) {
  const parts = query.split(':')
  const end = parts.pop()

  const completions = [ ]

  if (query && !/^\$\.$/.test(query)) {
    if (/^\$[a-z|A-Z|0-9|_]+$/g.test(end)) {
      completions.push(
        '$camelcase(',
        '$concat(',
        '$unique(',
        '$float(',
        '$int(',
        '$now(',
        '$slice(',
        '$toJSON',
      )
    } else if (/\.\$?([a-z|A-Z|0-9|_]+)?$/g.test(end)) {
      const i = query.lastIndexOf('.')
      const prefix = query.slice(0, i)
      completions.push(
        `${prefix}.$camelcase(`,
        `${prefix}.$concat(`,
        `${prefix}.$unique(`,
        `${prefix}.$float(`,
        `${prefix}.$int(`,
        `${prefix}.$now(`,
        `${prefix}.$slice`,
      )
    }
  }
  if (/children:?[a-z|A-Z|-]*$/.test(query)) {
    const colon = /children\:([a-z|A-Z|-]+)?$/.test(query)

    if (!colon) {
      completions.push(
        `${query}[0]`,
        `${query}[1]`,
        `${query}[2]`,
        `${query}[3]`,
        `${query}[4]`,
        `${query}[5]`,
        `${query}[6]`,
        `${query}[7]`,
        `${query}[8]`,
        `${query}[9]`
      )
    }

    completions.push(
      `${parts.join(':')}:first`,
      `${parts.join(':')}:second`,
      `${parts.join(':')}:third`,
      `${parts.join(':')}:fourth`,
      `${parts.join(':')}:fifth`,
      `${parts.join(':')}:sixth`,
      `${parts.join(':')}:seventh`,
      `${parts.join(':')}:eighth`,
      `${parts.join(':')}:ninth`,
      `${parts.join(':')}:tenth`
    )
  }

  if (!query || ':' === query || /\:?r?o?o?t?/.test(query)) {
    if (!/\.$/.test(end)) {
      completions.unshift(':root')
    }
  }

  if (/\[\s+$/.test(end)) {
    completions.push(
      'attributes',
      'children',
      'attr(',
      'name',
      'text'
    )
  }

  if (/\.$/.test(end)) {
    completions.push(
      'name',
      'body',
      'children',
      'attributes',
      'length'
    )
  } else {
    completions.push(
      ':is',
      ':json',
      ':keys',
      ':text',

      ':attr',
      ':attrs',

      ':children',
      ':nth-child',
    )
  }

  const hits = completions
    .filter((c) => parts.length && end ? c.startsWith(`:${end}`) : c.startsWith(query))
    //.map((c) => parts.join(':') + c)

  return  [hits.length ? unique(hits.sort()) : unique(completions.sort()), query]

  function unique(array) {
    return Array.from(new Set(array))
  }
}
