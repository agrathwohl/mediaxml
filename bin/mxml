#!/usr/bin/env node

const { Parser, ParserNode, ParserNodeFragment, ParserNodeAttributes } = require('../parser')
const { clearScreenDown, cursorTo, moveCursor } = require('readline')
const { inspect } = require('util')
const stripAnsi = require('strip-ansi')
const chokidar = require('chokidar')
const chromafi = require('@12core/chromafi')
const truncate = require('cli-truncate')
const mutexify = require('mutexify')
const prettyMs = require('pretty-ms')
const { URL } = require('url')
const mkdirp = require('mkdirp')
const debug = require('debug')('mediaxml')
const chalk = require('chalk')
const paths = require('env-paths')('mediaxml')
const glob = require('glob')
const path = require('path')
const repl = require('repl')
const get = require('get-uri')
const ora = require('ora')
const pkg = require('../package.json')
const fs = require('fs')

const argv = require('minimist')(process.argv.slice(2), {
  '--': true,
  alias: {
    h: ['help'],
    i: ['inspect'],
    D: ['debug'],
    R: ['repl'],
    T: ['timing'],
    V: ['version'],
    W: ['watch'],
  },

  boolean: [
    'debug',
    'inspect',
    'help',
    'no-preview',
    'preview',
    'repl',
    'timing',
    'version',
    'watch',
  ]
})

if (argv.help) {
  process.stdout.write('usage: mxml [-hiDRTV] [options] <filename> [query]\n')
  process.stdout.write('\n')
  process.stdout.write('options:\n')
  process.stdout.write('  -h, --help      Show this message\n')
  process.stdout.write('  -i, --inspect   Show inspected output\n')
  process.stdout.write('  -D, --debug     Show debug output\n')
  process.stdout.write('  -T, --timing    Show query timing debug output\n')
  process.stdout.write('  -V, --version   Show program version\n')
  process.stdout.write('  -W, --watch     Watch for changes (REPL context only)\n')
  process.stdout.write('\n')
  process.stdout.write('arguments:\n')
  process.stdout.write('  <filename>      Path to XML file (required)\n')
  process.stdout.write('  [query]         Query in JSONata syntax on resulting model [optional]\n')
  process.stdout.write('\n')
  process.stdout.write('examples:\n')
  process.stdout.write('  ## read ADI metadata\n')
  process.stdout.write('  mxml ./tvshow.xml \'adi:children [name="metadata"]\'\n')
  process.stdout.write('\n')
  process.stdout.write('  ## look for ADI3 "Movie" assets\n')
  process.stdout.write('  mxml ./movie.xml \'adi3:children [`xsi:type`="content:MovieType"]\'\n')
  process.stdout.write('\n')
  process.exit(0)
}

if (argv.version) {
  process.stdout.write(pkg.version)
  process.stdout.write('\n')
  process.exit(0)
}

if (argv.debug) {
  require('debug').enable('mediaxml')
  debug('Debug output enabled')
}

if (0 && !argv._[0] && process.stdin.isTTY) {
  console.error('error: Please specify a file path or URL')
  console.error('usage: mxml [-hiDV] [options] <uri> [query]')
  process.exit(1)
}

const assignments = {
  cwd: process.cwd(),
  argv0: argv._[0] || null,
  argv1: argv['--'][0] || null,
  argv2: argv['--'][1] || null,
  argv3: argv['--'][2] || null,
  argv4: argv['--'][3] || null,
}

const importing = new Set()
const imports = new Map()
const parser = new Parser()
const lock = mutexify()

let [ arg0, query = arg0 ] = argv._
let server = null
let watcher = null
let filename = null
let lastQuery = null
let currentDirname = process.cwd()
let documentNotLoadedWarningShown = false

const spinners = {
  loading: ora({
    discardStdin: false,
    hideCursor: false,
    indent: 0,
    spinner: 'aesthetic',
    color: 'cyan',
    prefixText: `${chalk.bold(chalk.italic('loading'))}:`
  })
}

process.on('uncaughtException', debug)
process.on('unhandledRejection', debug)

if (arg0 && query && arg0 === query) {
  query = null
}

// try to load query as file
if (query) {
  try {
    fs.accessSync(query)
    query = fs.readFileSync(query, 'utf8')
  } catch (err) {
    void err
  }
}

if ('-' === argv._[0] || !process.stdin.isTTY) {
  if (!query) {
    console.error('error: stdin is not a TTY and no query was given')
    console.error('usage: mxml [-hiDV] [options] <uri> [query]')
    process.exit(1)
  }

  oninitialstream(null, process.stdin)
} else {
  try {
    const { protocol } = new URL(argv._[0])
    filename = argv._[0]
  } catch (err) {
    if (err && 'ERR_INVALID_URL' !== err.code) {
      debug(err)
    } else {
      try {
        filename = path.resolve(process.cwd(), argv._[0])
        fs.accessSync(filename, fs.constants.R_OK | fs.constants.F_OK)
        filename = `file://${filename}`
      } catch (err) {
        void err
      }
    }
  }

  if (filename) {
    get(filename, oninitialstream)
  } else {
    startRepl()
  }
}

function oninitialstream(err, stream) {
  if (err) {
    console.error('error: %s', err.message)
    debug(err.stack || err)
    process.exit(1)
    return
  }

  const bytes = []
  parser.clear()
  stream
    .on('data', (d) => bytes.push(d))
    .pipe(parser.createWriteStream())
    .on('error', (err) => {
      console.error('error: %s', err.message)
      debug(err.stack || err)
    })
    .on('finish', async () => {
      if (query) {
        let result = null
        const now = Date.now()
        try {
          query = query.trim()
          result = parser.query(query, {
            assignments,
            imports,
            load,
            inspect: Boolean(argv.inspect)
          })
        } catch (err) {
          if (err && 'position' in err) {
            if (err.token) {
              console.error('%s: %s',
                chalk.red('error'),
                chalk.bold(err.message.replace(`"${err.token}"`, `"${chalk.yellow(err.token)}"`))
              )
            } else {
              debug(err || err.stack)
              console.error('%s: %s', chalk.red('error'), chalk.bold(err.message))
            }

            if (argv.timing) {
              console.error('%s: %s', chalk.bold('query'), prettyMs(Date.now() - now))
            }
          } else {
            debug(err.stack || err)
            if (argv.timing) {
              console.error('%s: %s', chalk.bold('query'), prettyMs(Date.now() - now))
            }
          }
        }

        if (result && argv.inspect) {
          output = pretty(result)

          if (output) {
            console.error('\n%s', output.trim())
          }
        } else if (argv.repl) {
          startRepl()
        } else {
          console.error(result)
        }
      } else if (process.stdin.isTTY) {
        if (!parser.rootNode) {
          try {
            await load(arg0)
            if (argv.repl) {
              startRepl()
            }
          } catch (err) {
            console.error('%s: %s', chalk.red('error'), chalk.bold(err.message))
            debug(err.stack || err)
            process.exit(1)
          }
        } else {
          startRepl()
        }
      }
    })
}

async function load(filenameToLoad) {
  filenameToLoad = filenameToLoad.replace(/file:\//, '')
  try {
    const { protocol } = new URL(filenameToLoad)
  } catch (err) {
    if (err && ('ERR_INVALID_URL' !== err.code && !err.message.test(/protocol/))) {
      debug(err)
    } else {
      filenameToLoad = path.resolve(currentDirname, filenameToLoad).replace('file://', '')
      try {
        fs.accessSync(filenameToLoad, fs.constants.R_OK | fs.constants.F_OK)
        if (!/file:\/\//.test(filenameToLoad)) {
          filenameToLoad = `file://${filenameToLoad}`
        }
      } catch (err) {
        if (err && 'ENOENT' !== err.code) {
          return Promise.reject(err)
        }

        return Promise.resolve(null)
      }
    }
  }

  const promise = new Promise((resolve, reject) => {
    lock((release) => {
      get(filenameToLoad, (err, stream) => {
        if (err) {
          console.error('%s: %s', chalk.red('error'), chalk.bold(err.message))
          debug(err.stack || err)
          reject(err)
          release()
        } else {
          filename = filenameToLoad
          currentDirname = path.dirname(filename).replace('file://', '')
          spinners.loading.start()
          process.nextTick(() => {
            const bytes = []
            const previousXML = parser.node && parser.node.outerXML
            stream
              .on('data', (d) => bytes.push(d))
              .on('error', (err) => {
                release()
                reject(err)
              })
              .on('end', async () => {
                spinners.loading.stop()

                if (server) {
                  server.setPrompt(`${chalk.bold('mxml')}(${chalk.italic(filename ? path.basename(filename.split('?')[0]) : '-')})> `)
                }

                if (argv.watch) {
                  watch()
                }

                const data = Buffer.concat(bytes).toString()
                const tmp = Parser.from(data)


                if (tmp.rootNode) {
                  parser.clear()
                  parser.write(tmp.rootNode.outerXML)
                  parser.end()
                }

                release()
                if (!tmp.rootNode) {
                  const query = data
                  lastQuery = query

                  let result = null
                  let endOfInput = false

                  try {
                    result = parser.query(query, { load, imports, assignments })
                  } catch (err) {
                    if (err && '(end)' !== err.token && !imports.size) {
                      release()
                      return reject(err)
                    }

                    if (err && '(end)' === err.token) {
                      endOfInput = true
                    }
                  }

                  if (imports.size) {
                    currentDirname = path.dirname(filename).replace('file://', '')
                    if (!endOfInput) {
                      result = parser.query(query, { load, imports, assignments })
                    }
                  }

                  if (result) {
                    if (result instanceof Promise) {
                      result = await result
                    }

                    const output = pretty(result)

                    if (output) {
                      process.stdout.write(output)
                      process.stdout.write('\n')
                    }
                  }
                } else {
                  let result = null

                  try {
                    query = data || query
                    result = parser.query(query, { load, imports, assignments })
                  } catch (err) {
                    if (err && '(end)' !== err.token && !imports.size) {
                      return reject(err)
                    }
                  }

                  if (result) {
                    if (result instanceof Promise) {
                      result = await result
                    }

                    const output = pretty(result)

                    if (output) {
                      process.stdout.write(output)
                      process.stdout.write('\n')
                    }

                    return resolve(result)
                  }
                }

                resolve(parser.rootNode)
              })
          })
        }
      })
    })
  })

  importing.add(promise)
  return promise
}

async function watch() {
  if (watcher) {
    await watcher.close()
  }

  const { pathname } = new URL(filename)
  watcher = chokidar.watch(pathname)
  watcher.on('change', () => {
    console.error()
    load(filename).then(async () => {
      //server.clearBufferedCommand()
      //server.displayPrompt()
      const { cursorPos, displayPos } = getCursorPreviewPosition(server)
      const cols = displayPos.cols - cursorPos.cols
      clearScreenDown(server.output)
      moveCursor(server.output, cols, 0)
      const query = server.line

      if (query) {
        let result = null

        try {
          result = parser.query(query, { load, imports, assignments })
        } catch (err) {
          if (err && '(end)' !== err.token && !imports.size) {
            throw err
          }
        }

        if (imports.size) {
          for (const [ importPath, importPromise ] of imports.entries()) {
            if (!importing.has(importPromise)) {
              await importPromise
              importing.add(importPromise)
            }
          }

          result = parser.query(query, { load, imports, assignments })
        }

        if (result instanceof Promise) {
          result = await result
        }

        process.nextTick(() => {
          let output = ''

          const { cursorPos, displayPos } = getCursorPreviewPosition(server)
          const cols = displayPos.cols - cursorPos.cols
          const rows = displayPos.rows - cursorPos.rows

          if (result) {
            output = pretty(result)

            if (output) {
              output = output.split('\n').slice(0, server.output.rows - rows - 1)
              const n = output.length
              output = output
                .map((o) => `${truncate(o, server.output.columns - 8)}`)
                .join('\n')

              moveCursor(server.output, cols, rows)
              clearScreenDown(server.output)
              server.output.write(`${output}`)
              cursorTo(server.output, cursorPos.cols)
              moveCursor(server.output, cols, -rows - n -1)
            }
          } else if (!query) {
            moveCursor(server.output, cols, rows)
            clearScreenDown(server.output)
          }
        })
      }
    })
  })
}

function startRepl() {
  let historyIndex = 0
  const history = []
  const inputBuffer = []

  process.stdin.setRawMode(true)

  process.stdin.on('keypress', async (str, key) => {
    if (argv['no-preview'] || argv.debug) {
      return
    }

    if ('backspace' === key.name && 0 === inputBuffer.length) {
      return
    }

    if (key.ctrl) {
      return
    }

    if ('up' === key.name) {
      historyIndex = Math.max(0, historyIndex - 1)
      key = history[historyIndex] || key
    } else if ('down' === key.name) {
      historyIndex = Math.min(history.length, historyIndex + 1)
      key = history[historyIndex] || key
    }

    if ('backspace' === key.name) {
      inputBuffer.pop()
    } else if ('return' === key.name) {
      inputBuffer.splice(0, inputBuffer.length)
      history.push(key)
      historyIndex = history.length - 1
      clearScreenDown(server.output)
    } else if (key.sequence) {
      inputBuffer.push(key.sequence)
    }

    const query = inputBuffer.join('').trim()
    let result = null

    if (query) {
      // double wildcards can be expensive
      if ('**' === query.trim()) {
        return
      }

      // don't just preview a print all willy nilly
      if (/^\s*?print\s*/.test(query.trim())) {
        return
      }

      try {
        result = parser.query(query, { load, imports, assignments })

        if (result instanceof Promise) {
          result = await result
        }
      } catch (err) {
      }
    }

    process.nextTick(() => {
      let output = ''

      const { cursorPos, displayPos } = getCursorPreviewPosition(server)
      const cols = displayPos.cols - cursorPos.cols
      const rows = displayPos.rows - cursorPos.rows

      if (result) {
        output = pretty(result)

        if (output) {
          output = output.split('\n').slice(0, server.output.rows - rows - 2)
          const n = output.length
          output = output
            .map((o) => `${truncate(o, server.output.columns - 8)}`)
            .join('\n')

          moveCursor(server.output, cols, rows)
          clearScreenDown(server.output)
          server.output.write(`\n${output}`)
          cursorTo(server.output, cursorPos.cols)
          moveCursor(server.output, cols, -rows - n)
        }
      } else if (!query) {
        moveCursor(server.output, cols, rows)
        clearScreenDown(server.output)
      }
    })
  })

  const replServerHistoryPath = path.join(paths.data, 'repl.history')

  console.error(`Welcome to the ${chalk.magenta(chalk.bold('MediaXML'))} %s CLI`, pkg.version)
  console.error('Please report bugs to %s', chalk.bold(chalk.italic(pkg.bugs.url)))

  if (!parser.rootNode) {
    console.error('Try using '+ chalk.bold('`import <URL>`') +' command to load an XML document into the context.')
  } else if (argv.watch) {
    watch()
  }

  server = repl.start({
    completer,
    terminal: true,
    prompt: `${chalk.bold('mxml')}(${chalk.italic(filename ? path.basename(filename.split('?')[0]) : '-')})> `,
    eval: evaluate
  })

  server.context = parser.rootNode
  server.on('error', (err) => {
    console.error('error:', err.message)
    debug(err.stack || err)
  })

  server.on('exit', () => {
    if (watcher) {
      watcher.close()
    }
  })

  try {
    mkdirp.sync(path.dirname(replServerHistoryPath))
  } catch (err) {
    console.error('error:', err.message)
    debug(err.stack || err)
    process.exit(1)
    return
  }

  server.setupHistory(replServerHistoryPath, (err) => {
    if (err) {
      debug(err.stack || err)
    }
  })
}

// borrowed from: https://github.com/nodejs/node/blob/master/lib/internal/repl/utils.js
function getCursorPreviewPosition(server) {
  const displayPos = server._getDisplayPos(`${server._prompt}${server.line}`)
  const cursorPos = server.line.length !== server.cursor
    ? server.getCursorPos()
    : displayPos
  return { displayPos, cursorPos }
}

function pretty(result) {
  if (
    !ParserNode.isParserNode(result) &&
    false === (result instanceof ParserNodeAttributes)
  ) {
    if (result && result._jsonata_function) {
      const name = (result.implementation.name || 'bound').replace(/^\$/, '')
      const signature = result.signature.definition
      const { description } = result.implementation
      return chalk.italic(`${chalk.cyan(name)}(${chalk.bold(signature)})`) + (
        description
        ? ` ${chalk.magenta('//')} ${chalk.italic(description)}`
        : ''
      )
    } else if ('function' === typeof result) {
      const name = (result.name || 'bound').replace(/^\$/, '')
      const signature = '...'
      return chalk.italic(`${chalk.cyan(name)}(${chalk.bold(signature)})`)
    } else {
      return inspect(result, { colors: true })
    }
  }

  let output = inspect.custom in result ? result[inspect.custom]() : result

  if (Array.isArray(output)) {
    return output.reduce((s, o) => s + (
      print((o && 'object' === typeof o && inspect.custom in o ) ? o[inspect.custom]() : o)
    ) + '\n', '')
  }

  return print(output)

  function print(out) {
    if (false === (out instanceof String) && 'object' !== typeof out && 'string' !== typeof out) {
      return out
    }

    return chromafi(out, {
      consoleTabWidth: 0,
      lineNumberPad: 0,
      tabsToSpaces: 2,
      lineNumbers: false,
      stripIndent: false,
      decorate: false,
      codePad: 0,
      lang: 'xml'
    })
  }
}

async function evaluate(query, context, file, callback) {
  try {
    query = query.trim()

    if (!query) {
      return callback(null, null)
    }

    const now = Date.now()

    if (!query) {
      if (argv.timing) {
        console.error('%s: %s', chalk.magenta(chalk.bold('query')), prettyMs(Date.now() - now))
      }
      return process.nextTick(callback, null)
    }

    try {
      let result = null
      let endOfInput = false

      try {
        result = parser.query(query, { load, imports, assignments })
      } catch (err) {
        if (err && '(end)' !== err.token && !imports.size) {
          throw err
        }

        if (err && '(end)' === err.token) {
          endOfInput = true
        }
      }

      if (result instanceof Promise) {
        result = await result
      }

      const output = pretty(result)

      if (!parser.rootNode && !documentNotLoadedWarningShown) {
        documentNotLoadedWarningShown = true
        console.error()
        console.error('%s: %s', chalk.bold(chalk.yellow(' warn')), 'Document not loaded into context. The query cannot be executed.')
        console.error('%s: %s', chalk.bold(chalk.yellow(' warn')), `Try using \`${chalk.cyan('load')} <URL>\` command to load an XML document into the context.`)
        console.error()
      }

      if (output) {
        process.stdout.write(output)
        process.stdout.write('\n')
      }

      if (argv.timing) {
        console.error('%s: %s', chalk.magenta(chalk.bold('query')), prettyMs(Date.now() - now))
      }

      return process.nextTick(callback, null)
    } catch (err) {
      debug(err || err.stack)

      const { cursorPos, displayPos } = getCursorPreviewPosition(server)
      const cols = displayPos.cols - cursorPos.cols
      const rows = displayPos.rows - cursorPos.rows

      moveCursor(server.output, cols, rows + 1)
      clearScreenDown(server.output)

      if (err && '(end)' === err.token) {
        return process.nextTick(callback, new repl.Recoverable(err))
      }

      if (err && 'object' === typeof err && 'position' in err) {
        if (err.token) {
          console.error('%s: %s',
            chalk.red('error'),
            chalk.bold(err.message.replace(`"${err.token}"`, `"${chalk.yellow(err.token)}"`))
          )
        } else {
          console.error('%s: %s', chalk.red('error'), chalk.bold(err.message))
        }

        if (argv.timing) {
          console.error('%s: %s', chalk.magenta(chalk.bold('query')), prettyMs(Date.now() - now))
        }

        process.nextTick(callback, null)
      } else {
        debug(err.stack || err)

        if (argv.timing) {
          console.error('%s: %s', chalk.magenta(chalk.bold('query')), prettyMs(Date.now() - now))
        }

        process.nextTick(callback, err.message || err)
      }
    }
  } catch (err) {
    debug(err.stack || err)
    callback('An unknown error has occurred. Try using relaunching with `--debug`.')
  }
}

function completer(query) {
  const parts = query.split(':')
  const end = parts.pop()

  const completions = [ ]

  if (query) {
    const pathToLoad = query.match(/\bimport\s*(['|"])?(.*)['|"]?\s*?/)
    if (pathToLoad) {
      let [, quote, pathspec ] = pathToLoad

      if (pathspec) {
        let hits = glob.sync(pathspec + '*')
        if (!hits || !hits.length) {
          hits = glob.sync(pathspec + '**')
        }

        for (const hit of hits) {
          const stat = fs.statSync(hit)
          if (stat.isDirectory()) {
            completions.push(query.replace(pathspec, hit + path.sep))
          } else {
            completions.push(query.replace(pathspec, hit))
          }
        }

      }
    }
  }

  if (query && !/^\$\.$/.test(query)) {
    if (/^\$[a-z|A-Z|0-9|_]+$/g.test(end)) {
      completions.push(
        '$camelcase(',
        '$concat(',
        '$unique(',
        '$float(',
        '$int(',
        '$now(',
        '$import(',
        '$slice(',
        '$toJSON',
      )
    } else if (/\.\$?([a-z|A-Z|0-9|_]+)?$/g.test(end)) {
      const i = query.lastIndexOf('.')
      const prefix = query.slice(0, i)
      completions.push(
        `${prefix}.$camelcase(`,
        `${prefix}.$concat(`,
        `${prefix}.$unique(`,
        `${prefix}.$float(`,
        `${prefix}.$int(`,
        `${prefix}.$now(`,
        `${prefix}.$slice(`,
        `${prefix}.$string(`,
      )
    }
  }
  if (/children:?[a-z|A-Z|-]*$/.test(query)) {
    const colon = /children\:([a-z|A-Z|-]+)?$/.test(query)

    if (!colon) {
      completions.push(
        `${query}[0]`,
        `${query}[1]`,
        `${query}[2]`,
        `${query}[3]`,
        `${query}[4]`,
        `${query}[5]`,
        `${query}[6]`,
        `${query}[7]`,
        `${query}[8]`,
        `${query}[9]`
      )
    }

    completions.push(
      `${parts.join(':')}:first`,
      `${parts.join(':')}:second`,
      `${parts.join(':')}:third`,
      `${parts.join(':')}:fourth`,
      `${parts.join(':')}:fifth`,
      `${parts.join(':')}:sixth`,
      `${parts.join(':')}:seventh`,
      `${parts.join(':')}:eighth`,
      `${parts.join(':')}:ninth`,
      `${parts.join(':')}:tenth`
    )
  }

  if (!query || ':' === query || /\:?r?o?o?t?/.test(query)) {
    if (!/\.$/.test(end)) {
      completions.unshift(':root')
    }
  }

  if (/\[(is|attributes|children|name|text)?\s*(.*)$/i.test(end)) {
    completions.push(
      'attributes',
      'children',
      'attr(',
      'name',
      'text',
      'import',
      'is',
      'is array',
      'is date',
      'is fragment',
      'is node',
      'is number',
      'is object',
      'is text',
      'is string',
    )
  }

  if (/\.$/.test(end)) {
    completions.push(
      'name',
      'text',
      'children',
      'attributes',
      'length'
    )
  } else {
    completions.push(
      ':is',
      ':is(array)',
      ':is(date)',
      ':is(fragment)',
      ':is(node)',
      ':is(number)',
      ':is(object)',
      ':is(text)',
      ':is(string)',
      ':json',
      ':keys',
      ':text',

      ':attr',
      ':attrs',

      ':children',
      ':nth-child',
    )
  }

  const hits = completions.filter((c) => {
    return parts.length && end ? c.startsWith(`:${end}`) : c.startsWith(query)
  })

  return  [
    hits.length ? unique(hits.sort()) : unique(completions.sort()),
    query
  ]

  function unique(array) {
    return Array.from(new Set(array))
  }
}
