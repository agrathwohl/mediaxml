#!/usr/bin/env node

const { Parser, ParserNode, ParserNodeFragment, ParserNodeAttributes } = require('../parser')
const { clearScreenDown, cursorTo, moveCursor } = require('readline')
const { inspect } = require('util')
const stripAnsi = require('strip-ansi')
const chromafi = require('@12core/chromafi')
const truncate = require('cli-truncate')
const prettyMs = require('pretty-ms')
const { URL } = require('url')
const mkdirp = require('mkdirp')
const debug = require('debug')('mediaxml')
const chalk = require('chalk')
const paths = require('env-paths')('mediaxml')
const glob = require('glob')
const path = require('path')
const repl = require('repl')
const get = require('get-uri')
const ora = require('ora')
const pkg = require('../package.json')
const fs = require('fs')

const argv = require('minimist')(process.argv.slice(2), {
  alias: {
    h: ['help'],
    i: ['inspect'],
    D: ['debug'],
    V: ['version'],
  },

  boolean: [
    'version',
    'inspect',
    'debug',
    'help'
  ]
})

if (argv.help) {
  console.log('usage: mxml [-hiDV] [options] <filename> [query]')
  console.log('')
  console.log('options:')
  console.log('  -h, --help      Show this message')
  console.log('  -i, --inspect   Show inspected output')
  console.log('  -D, --debug     Show debug output')
  console.log('  -V, --version   Show program version')
  console.log('')
  console.log('arguments:')
  console.log('  <filename>      Path to XML file (required)')
  console.log('  [query]         Query in JSONata syntax on resulting model [optional]')
  console.log('')
  console.log('examples:')
  console.log('  ## read ADI metadata')
  console.log('  mxml ./tvshow.xml \'adi:children [name="metadata"]\'')
  console.log('')
  console.log('  ## look for ADI3 "Movie" assets')
  console.log('  mxml ./movie.xml \'adi3:children [`xsi:type`="content:MovieType"]\'')
  console.log('')
  process.exit(0)
}

if (argv.version) {
  console.log(pkg.version)
  process.exit(0)
}

if (argv.debug) {
  require('debug').enable('mediaxml')
  debug('Debug output enabled')
}

if (0 && !argv._[0] && process.stdin.isTTY) {
  console.error('error: Please specify a file path or URL')
  console.error('usage: mxml [-hiDV] [options] <uri> [query]')
  process.exit(1)
}

const parser = new Parser()
let [ arg0, query = arg0 ] = argv._
let filename = null
const spinners = {
  loading: ora({
    discardStdin: false,
    hideCursor: false,
    indent: 0,
    spinner: 'aesthetic',
    color: 'cyan',
    prefixText: `${chalk.bold(chalk.italic('loading'))}:`
  }),

  preview: ora({
    discardStdin: false,
    hideCursor: false,
    indent: 0,
    color: 'cyan',
  }),
}

if (arg0 && query && arg0 === query) {
  query = null
}

// try to load query as file
if (query) {
  try {
    fs.accessSync(query)
    query = fs.readFileSync(query, 'utf8')
  } catch (err) {
    void err
  }
}

if ('-' === argv._[0] || !process.stdin.isTTY) {
  if (!query) {
    console.error('error: stdin is not a TTY and no query was given')
    console.error('usage: mxml [-hiDV] [options] <uri> [query]')
    process.exit(1)
  }

  onstream(null, process.stdin)
} else {
  try {
    const { protocol } = new URL(argv._[0])
    filename = argv._[0]
  } catch (err) {
    if (err && 'ERR_INVALID_URL' !== err.code) {
      debug(err)
    } else {
      try {
        filename = path.resolve(process.cwd(), argv._[0])
        fs.accessSync(filename, fs.constants.R_OK | fs.constants.F_OK)
        filename = `file://${filename}`
      } catch (err) {
        void err
      }
    }
  }

  if (filename) {
    get(filename, onstream)
  } else {
    startRepl()
  }
}

function onstream(err, stream) {
  if (err) {
    console.error('error: %s', err.message)
    debug(err.stack || err)
    process.exit(1)
    return
  }

  stream.pipe(parser.createWriteStream())
    .on('error', (err) => {
      console.error('error: %s', err.message)
      debug(err.stack || err)
    })
    .on('finish', () => {
      if (query) {
        let result = null
        const now = Date.now()
        try {
          query = query.trim()

          result = parser.query(query, {
            inspect: Boolean(argv.inspect)
          })
        } catch (err) {
          if (err && 'position' in err) {
            if (err.token) {
              console.error('%s: %s',
                chalk.red('error'),
                chalk.bold(err.message.replace(`"${err.token}"`, `"${chalk.yellow(err.token)}"`))
              )
            } else {
              console.error('%s: %s', chalk.red('error'), chalk.bold(err.message))
            }

            console.error('%s: %s', chalk.bold('query'), prettyMs(Date.now() - now))
          } else {
            debug(err.stack || err)
            console.error('%s: %s', chalk.bold('query'), prettyMs(Date.now() - now))
          }
        }

        if (result && argv.inspect) {
          output = pretty(result)

          if (output) {
            console.error('\n%s', output.trim())
          }
        } else {
          console.error(result)
        }
      } else if (process.stdin.isTTY) {
        startRepl()
      }
    })
}

function startRepl() {
  let historyIndex = 0
  const history = []
  const inputBuffer = []

  process.stdin.setRawMode(true)

  process.stdin.on('keypress', async (str, key) => {
    if ('backspace' === key.name && 0 === inputBuffer.length) {
      return
    }

    if (key.ctrl) {
      return
    }

    if ('up' === key.name) {
      historyIndex = Math.max(0, historyIndex - 1)
      key = history[historyIndex] || key
    } else if ('down' === key.name) {
      historyIndex = Math.min(history.length, historyIndex + 1)
      key = history[historyIndex] || key
    }

    if ('backspace' === key.name) {
      inputBuffer.pop()
    } else if ('return' === key.name) {
      inputBuffer.splice(0, inputBuffer.length)
      history.push(key)
      historyIndex = history.length - 1
    } else if (key.sequence) {
      inputBuffer.push(key.sequence)
    }

    const query = inputBuffer.join('').trim()
    let result = null

    if (query) {
      try {
        result = parser.query(query)

        if (result instanceof Promise) {
          result = await result
        }
      } catch (err) {
      }
    }

    process.nextTick(() => {
      let output = ''

      const { cursorPos, displayPos } = getCursorPreviewPosition(server)
      const cols = displayPos.cols - cursorPos.cols
      const rows = displayPos.rows - cursorPos.rows

      if (result) {
        output = pretty(result)

        if (output) {
          output = output.split('\n').slice(0, server.output.rows - rows - 2)
          const n = output.length
          output = output
            .map((o) => `${truncate(o, server.output.columns - 8)}`)
            .join('\n')

          moveCursor(server.output, cols, rows)
          clearScreenDown(server.output)
          server.output.write(`\n${output}`)
          cursorTo(server.output, cursorPos.cols)
          moveCursor(server.output, cols, -rows - n)
        }
      } else if (!query) {
        moveCursor(server.output, cols, rows)
        clearScreenDown(server.output)
      }
    })
  })

  const replServerHistoryPath = path.join(paths.data, 'repl.history')
  console.error(`Welcome to the ${chalk.magenta(chalk.bold('MediaXML'))} %s CLI`, pkg.version)
  console.error('Please report bugs to %s', chalk.bold(chalk.italic(pkg.bugs.url)))

  if (!parser.rootNode) {
    console.error('Load a XML document with the `load <URL>`')
  }

  const server = repl.start({
    completer,
    terminal: true,
    prompt: `${chalk.bold('mxml')}(${chalk.italic(filename ? path.basename(filename.split('?')[0]) : '-')})> `,
    eval: evaluate
  })

  server.context = parser.rootNode
  server.on('error', (err) => {
    console.error('error:', err.message)
    debug(err.stack || err)
  })

  try {
    mkdirp.sync(path.dirname(replServerHistoryPath))
  } catch (err) {
    console.error('error:', err.message)
    debug(err.stack || err)
    process.exit(1)
    return
  }

  server.setupHistory(replServerHistoryPath, (err) => {
    if (err) {
      debug(err.stack || err)
    }
  })

  parser.options.bindings.load = (filenameToLoad) => {
    filename = filenameToLoad
    try {
      const { protocol } = new URL(filename)
    } catch (err) {
      if (err && 'ERR_INVALID_URL' !== err.code) {
        debug(err)
      } else {
        try {
          filename = path.resolve(process.cwd(), filename)
          fs.accessSync(filename, fs.constants.R_OK | fs.constants.F_OK)
          filename = `file://${filename}`
        } catch (err) {
          void err
        }
      }
    }

    return new Promise((resolve, reject) => {
      get(filename, (err, stream) => {
        if (err) {
          console.error('%s: %s', chalk.red('error'), chalk.bold(err.message))
          debug(err.stack || err)
          reject(err)
        } else {
          parser.clear()
          spinners.loading.start()
          process.nextTick(() => {
            stream.pipe(parser.createWriteStream())
              .on('error', reject)
              .on('finish', () => {
                spinners.loading.stop()
                server.setPrompt(`${chalk.bold('mxml')}(${chalk.italic(filename ? path.basename(filename.split('?')[0]) : '-')})> `)
                resolve(parser.rootNode)
              })
          })
        }
      })
    })
  }

  parser.options.bindings.load.signature = '<s:x>'
}

// borrowed from: https://github.com/nodejs/node/blob/master/lib/internal/repl/utils.js
function getCursorPreviewPosition(server) {
  const displayPos = server._getDisplayPos(`${server._prompt}${server.line}`)
  const cursorPos = server.line.length !== server.cursor
    ? server.getCursorPos()
    : displayPos
  return { displayPos, cursorPos }
}

function pretty(result) {
  if (
    !ParserNode.isParserNode(result) &&
    false === (result instanceof ParserNodeAttributes)
  ) {
    return inspect(result, { colors: true })
  }

  let output = inspect.custom in result ? result[inspect.custom]() : result

  if (Array.isArray(output)) {
    return output.reduce((s, o) => s + (
      print((o && 'object' === typeof o && inspect.custom in o ) ? o[inspect.custom]() : o)
    ) + '\n', '')
  }

  return print(output)

  function print(out) {
    if (false === (out instanceof String) && 'object' !== typeof out && 'string' !== typeof out) {
      return out
    }

    return chromafi(out, {
      consoleTabWidth: 0,
      lineNumberPad: 0,
      tabsToSpaces: 2,
      lineNumbers: false,
      stripIndent: false,
      decorate: false,
      codePad: 0,
      lang: 'xml'
    })
  }
}

async function evaluate(query, context, file, callback) {
  try {
    query = query.trim()
      .replace(/(\$?load\s*?)[\'|"]?([0-9|a-z|A-Z|\-|_|\$|.|\:|\(|\)|\&|\%|\#|\@|\*|\!|\/|\\|\?|=|\+]+)[\'|"]?\s*?/ig, '$load("$2")')

    const now = Date.now()

    if (!query) {
      console.error('%s: %s', chalk.magenta(chalk.bold('query')), prettyMs(Date.now() - now))
      return process.nextTick(callback, null)
    }

    try {
      let result = parser.query(query)

      if (result instanceof Promise) {
        result = await result
      }

      if (!parser.rootNode) {
        console.error('%s: %s', chalk.bold(chalk.yellow('warn')), 'Document not loaded.')
        console.error('%s: %s', chalk.bold(chalk.yellow('warn')), 'Query cannot be executed.')
        console.error('%s: %s', chalk.bold(chalk.yellow('warn')), 'Try using `load <URL>`')
      }

      const output = pretty(result)
      if (output) {
        process.stdout.write(output)
        process.stdout.write('\n')
      }

      console.error('%s: %s', chalk.magenta(chalk.bold('query')), prettyMs(Date.now() - now))
      return process.nextTick(callback, null)
    } catch (err) {
      const { cursorPos, displayPos } = getCursorPreviewPosition(server)
      const cols = displayPos.cols - cursorPos.cols
      const rows = displayPos.rows - cursorPos.rows

      moveCursor(server.output, cols, rows + 1)
      clearScreenDown(server.output)

      if (err && '(end)' === err.token) {
        return process.nextTick(callback, new repl.Recoverable(err))
      }

      if (err && 'object' === typeof err && 'position' in err) {
        if (err.token) {
          console.error('%s: %s',
            chalk.red('error'),
            chalk.bold(err.message.replace(`"${err.token}"`, `"${chalk.yellow(err.token)}"`))
          )
        } else {
          console.error('%s: %s', chalk.red('error'), chalk.bold(err.message))
        }

        console.error('%s: %s', chalk.magenta(chalk.bold('query')), prettyMs(Date.now() - now))
        process.nextTick(callback, null)
      } else {
        debug(err.stack || err)
        console.error('%s: %s', chalk.magenta(chalk.bold('query')), prettyMs(Date.now() - now))
        process.nextTick(callback, err.message || err)
      }
    }
  } catch (err) {
    debug(err.stack || err)
    callback('An unknown error has occurred. Try using relaunching with `--debug`.')
  }
}

function completer(query) {
  const parts = query.split(':')
  const end = parts.pop()

  const completions = [ ]

  if (query) {
    const pathToLoad = query.match(/\$?load\(?\s*(['|"])?(.*)['|"]?\s*\)?/)
    if (pathToLoad) {
      let [, quote, pathspec ] = pathToLoad

      if (pathspec) {
        let hits = glob.sync(pathspec + '*')
        if (!hits || !hits.length) {
          hits = glob.sync(pathspec + '**')
        }

        for (const hit of hits) {
          const stat = fs.statSync(hit)
          if (stat.isDirectory()) {
            completions.push(query.replace(pathspec, hit + path.sep))
          } else {
            completions.push(query.replace(pathspec, hit))
          }
        }

      }
    }
  }

  if (query && !/^\$\.$/.test(query)) {
    if (/^\$[a-z|A-Z|0-9|_]+$/g.test(end)) {
      completions.push(
        '$camelcase(',
        '$concat(',
        '$unique(',
        '$float(',
        '$int(',
        '$now(',
        '$load(',
        '$slice(',
        '$toJSON',
      )
    } else if (/\.\$?([a-z|A-Z|0-9|_]+)?$/g.test(end)) {
      const i = query.lastIndexOf('.')
      const prefix = query.slice(0, i)
      completions.push(
        `${prefix}.$camelcase(`,
        `${prefix}.$concat(`,
        `${prefix}.$unique(`,
        `${prefix}.$float(`,
        `${prefix}.$int(`,
        `${prefix}.$now(`,
        `${prefix}.$slice(`,
        `${prefix}.$string(`,
      )
    }
  }
  if (/children:?[a-z|A-Z|-]*$/.test(query)) {
    const colon = /children\:([a-z|A-Z|-]+)?$/.test(query)

    if (!colon) {
      completions.push(
        `${query}[0]`,
        `${query}[1]`,
        `${query}[2]`,
        `${query}[3]`,
        `${query}[4]`,
        `${query}[5]`,
        `${query}[6]`,
        `${query}[7]`,
        `${query}[8]`,
        `${query}[9]`
      )
    }

    completions.push(
      `${parts.join(':')}:first`,
      `${parts.join(':')}:second`,
      `${parts.join(':')}:third`,
      `${parts.join(':')}:fourth`,
      `${parts.join(':')}:fifth`,
      `${parts.join(':')}:sixth`,
      `${parts.join(':')}:seventh`,
      `${parts.join(':')}:eighth`,
      `${parts.join(':')}:ninth`,
      `${parts.join(':')}:tenth`
    )
  }

  if (!query || ':' === query || /\:?r?o?o?t?/.test(query)) {
    if (!/\.$/.test(end)) {
      completions.unshift(':root')
    }
  }

  if (/\[(is|attributes|children|name|text)?\s*(.*)$/i.test(end)) {
    completions.push(
      'attributes',
      'children',
      'attr(',
      'name',
      'text',
      'load',
      'is',
      'is array',
      'is date',
      'is fragment',
      'is node',
      'is number',
      'is object',
      'is text',
      'is string',
    )
  }

  if (/\.$/.test(end)) {
    completions.push(
      'name',
      'body',
      'children',
      'attributes',
      'length'
    )
  } else {
    completions.push(
      ':is',
      ':is(array)',
      ':is(date)',
      ':is(fragment)',
      ':is(node)',
      ':is(number)',
      ':is(object)',
      ':is(text)',
      ':is(string)',
      ':json',
      ':keys',
      ':text',

      ':attr',
      ':attrs',

      ':children',
      ':nth-child',
    )
  }

  const hits = completions.filter((c) => {
    return parts.length && end ? c.startsWith(`:${end}`) : c.startsWith(query)
  })

  return  [
    hits.length ? unique(hits.sort()) : unique(completions.sort()),
    query
  ]

  function unique(array) {
    return Array.from(new Set(array))
  }
}
